import pytest


@pytest.fixture()
def sesh_with_basics(schema_name, sesh_in_prepared_schema_left):
    sesh = sesh_in_prepared_schema_left
    sesh.execute(f"SET search_path TO {schema_name}, public")
    yield sesh_in_prepared_schema_left


@pytest.fixture()
def sesh_with_test_tables(sesh_with_basics):
    sesh = sesh_with_basics
    sesh.execute(
        f"""
CREATE TABLE a (
    -- Main attributes
    a_id SERIAL PRIMARY KEY,
    x INTEGER,
    -- History-related attributes
    mod_time timestamp WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    mod_user character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER
); 
        
CREATE TRIGGER t100_primary_control_hx_cols
    BEFORE INSERT OR DELETE OR UPDATE
    ON a
    FOR EACH ROW
EXECUTE FUNCTION hxtk_primary_control_hx_cols();

CREATE TRIGGER t100_primary_ops_to_hx
    AFTER INSERT OR DELETE OR UPDATE
    ON a
    FOR EACH ROW
EXECUTE FUNCTION hxtk_primary_ops_to_hx();

CREATE TABLE b (
    -- Main attributes
    b_id SERIAL PRIMARY KEY,
    a_id INTEGER REFERENCES a (a_id),
    y INTEGER,
    -- History-related attributes
    mod_time timestamp WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    mod_user character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER
);

CREATE TRIGGER t100_primary_control_hx_cols
    BEFORE INSERT OR DELETE OR UPDATE
    ON b
    FOR EACH ROW
EXECUTE FUNCTION hxtk_primary_control_hx_cols();

CREATE TRIGGER t100_primary_ops_to_hx
    AFTER INSERT OR DELETE OR UPDATE
    ON b
    FOR EACH ROW
EXECUTE FUNCTION hxtk_primary_ops_to_hx();

-- History tables
CREATE TABLE a_hx (
    a_id INTEGER,
    x INTEGER,
    mod_time timestamp WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    mod_user character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER,
    -- History columns
    deleted BOOLEAN NOT NULL DEFAULT FALSE,
    a_hx_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
    -- Foreign key columns (none in this table)
);

CREATE TABLE b_hx (
    -- Must parallel primary table cols: $1.* (NEW.*/OLD.*)
    b_id INTEGER,
    a_id INTEGER,
    y INTEGER,
    mod_time timestamp WITHOUT TIME ZONE NOT NULL DEFAULT NOW(),
    mod_user character varying(64) COLLATE pg_catalog."default" NOT NULL DEFAULT CURRENT_USER,
    -- History columns
    deleted BOOLEAN NOT NULL DEFAULT FALSE,
    b_hx_id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    -- Foreign key columns. 
    a_hx_id INTEGER REFERENCES a_hx (a_hx_id) -- inserted by trigger fn
);

CREATE TRIGGER t100_add_foreign_hx_keys
    BEFORE INSERT
    ON b_hx
    FOR EACH ROW
EXECUTE FUNCTION hxtk_add_foreign_hx_keys('{{a, a_id}}');
               
        """
    )
    yield sesh


populate_a = """
    INSERT INTO a(x) VALUES (100), (200), (300), (400);
    
    UPDATE a SET x = 101 WHERE a_id = 1;
    UPDATE a SET x = 102 WHERE a_id = 1;
    DELETE FROM a WHERE a_id = 1;
    
    UPDATE a SET x = 201 WHERE a_id = 2;
    UPDATE a SET x = 202 WHERE a_id = 2;
    
    UPDATE a SET x = 301 WHERE a_id = 3;
    """

populate_b = """
    INSERT INTO b(a_id, y) VALUES (2, 200), (3, 300);
    UPDATE b SET a_id = 3 WHERE b_id = 1;
    """


@pytest.mark.usefixtures("new_db_left")
@pytest.mark.parametrize(
    "operations, query, expected",
    [
        (
            populate_a,
            # Note: a_hx_id is trivial here but helps us determine values for next test
            "SELECT a_id, x, deleted, a_hx_id FROM a_hx ORDER BY a_hx_id",
            (
                (1, 100, False, 1),
                (2, 200, False, 2),
                (3, 300, False, 3),
                (4, 400, False, 4),
                (1, 101, False, 5),
                (1, 102, False, 6),
                (1, 102, True, 7),
                (2, 201, False, 8),
                (2, 202, False, 9),
                (3, 301, False, 10),
            ),
        ),
        (
            populate_a + populate_b,
            # Note we test a_hx_id, which is a FK to a_hx table.
            "SELECT b_id, a_id, y, deleted, a_hx_id FROM b_hx ORDER BY b_hx_id",
            (
                (1, 2, 200, False, 9),
                (2, 3, 300, False, 10),
                (1, 3, 200, False, 10),
            ),
        ),
    ],
)
def test_history(operations, query, expected, sesh_with_test_tables):
    """
    Test contents of history tables after operations.
    This is actually a pretty generic test: do ops, query, check results,
    but that's what we're using it for here.
    """
    sesh = sesh_with_test_tables
    sesh.execute(operations)
    result = sesh.execute(query).fetchall()
    assert tuple(result) == expected


@pytest.mark.usefixtures("new_db_left")
def test_mod_values_enforcement(sesh_with_test_tables):
    """
    Test enforcement of mod_time, mod_user in both primary and history table.
    """
    sesh = sesh_with_test_tables

    # Get expected values
    # Note that now() returns the same value within a single transaction, which
    # a test session like this is.
    expected = sesh.execute("SELECT now()::timestamp, current_user").fetchone()

    # Attempt to override mod_time, mod_user
    sesh.execute(
        "INSERT INTO a(x, mod_time, mod_user) "
        "VALUES (100, '2000-01-01 00:00'::timestamp, 'naughty')"
    )

    # Check they are not overridden
    result = sesh.execute("SELECT mod_time, mod_user FROM a").first()
    assert result == expected
    result = sesh.execute("SELECT mod_time, mod_user FROM a_hx").first()
    assert result == expected
