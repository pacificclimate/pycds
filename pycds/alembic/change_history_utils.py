"""
Utility functions supporting change history migrations.
These are Python functions, not database functions, and they are used in coding the
migration. Naming functions do correspond to equivalent database functions used by
the change history functionality.
"""
from typing import Iterable, Any

from alembic import op

from pycds import get_schema_name


schema_name = get_schema_name()


def qualified_name(name: str) -> str:
    return f"{schema_name}.{name}"


def pri_table_name(collection_name: str, qualify=True) -> str:
    return qualified_name(collection_name) if qualify else collection_name


def hx_table_name(collection_name: str, **kwargs) -> str:
    return f"{pri_table_name(collection_name, **kwargs)}_hx"


def hx_id_name(collection_name: str, **kwargs):
    return f"{collection_name}_hx_id"


def sql_array(a: Iterable[Any]) -> str:
    return f"{{{', '.join(a)}}}"


def add_history_cols_to_primary(collection_name: str):
    # op.add_column can add only one column at a time.
    # Tables can be large, so for efficiency we add both columns in one command.
    op.execute(
        f"ALTER TABLE {pri_table_name(collection_name)} "
        f"  ADD COLUMN mod_time timestamp without time zone NOT NULL DEFAULT NOW(), "
        f'  ADD COLUMN mod_user character varying(64) COLLATE pg_catalog."default" '
        f"      NOT NULL DEFAULT CURRENT_USER"
    )


def drop_history_cols_from_primary(collection_name: str):
    op.execute(
        f"ALTER TABLE {pri_table_name(collection_name)} "
        f"  DROP COLUMN mod_time, "
        f"  DROP COLUMN mod_user"
    )


def create_history_table(collection_name: str, foreign_keys: list[str, str]):
    # Create the history table. We can't use Alembic create_table here because it doesn't
    # support the LIKE syntax we need.
    columns = ", ".join(
        (
            f"  LIKE {pri_table_name(collection_name)} INCLUDING ALL EXCLUDING INDEXES",
            f"  deleted boolean DEFAULT false",
            f"  {hx_id_name(collection_name)} int "
            f"      PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
        )
        + tuple(
            f"{hx_id_name(fk_table_name)} int "
            f"  REFERENCES {hx_table_name(fk_table_name)}({hx_id_name(fk_table_name)})"
            for fk_table_name, _ in (foreign_keys or tuple())
        )
    )
    op.execute(f"CREATE TABLE {hx_table_name(collection_name)} ({columns})")


def drop_history_table(collection_name: str):
    # Alternative: use op.drop_table
    op.execute(f"DROP TABLE {hx_table_name(collection_name)}")


def create_history_table_indexes(collection_name: str, pri_id_name: str):
    # How much do we care about index naming? SQLAlchemy uses a different pattern than
    # appears typical in CRMP.
    op.create_index(
        None,  # Use default SQLA index name.
        hx_table_name(collection_name, qualify=False),
        [pri_id_name],
        schema=schema_name,
    )


def populate_history_table(collection_name: str, pri_id_name: str):
    # Populate the history table with data from the primary table, in order of primary id.
    # That ordering guarantees that the newly generated history id's will be in the
    # same order, which is required for it to be a valid history table.
    op.execute(
        f"INSERT INTO {hx_table_name(collection_name)} "
        f"SELECT * "
        f"FROM {pri_table_name(collection_name)} "
        f"ORDER BY {pri_table_name(collection_name)}.{pri_id_name}"
    )


def create_primary_table_triggers(collection_name: str, prefix: str = "t100_"):
    # Trigger: Enforce mod_time and mod_user values on primary table.
    op.execute(
        f"CREATE TRIGGER {prefix}primary_control_hx_cols "
        f"    BEFORE INSERT OR DELETE OR UPDATE "
        f"    ON {pri_table_name(collection_name)} "
        f"    FOR EACH ROW "
        f"    EXECUTE FUNCTION {qualified_name('hxtk_primary_control_hx_cols')}()"
    )

    # Trigger: Append history records to history table when primary updated.
    op.execute(
        f"CREATE TRIGGER {prefix}primary_ops_to_hx "
        f"    AFTER INSERT OR DELETE OR UPDATE "
        f"    ON {pri_table_name(collection_name)} "
        f"    FOR EACH ROW "
        f"    EXECUTE FUNCTION {qualified_name('hxtk_primary_ops_to_hx')}()"
    )


def create_history_table_triggers(
    collection_name: str, foreign_keys: list, prefix: str = "t100_"
):
    # Trigger: Add foreign key values to each record inserted into history table.
    fk_args = (
        f"'{sql_array(sql_array(pair) for pair in foreign_keys)}'"
        if foreign_keys
        else ""
    )
    op.execute(
        f"CREATE TRIGGER {prefix}add_foreign_hx_keys "
        f"    BEFORE INSERT "
        f"    ON {hx_table_name(collection_name)} "
        f"    FOR EACH ROW "
        f"    EXECUTE FUNCTION {qualified_name('hxtk_add_foreign_hx_keys')}({fk_args})"
    )


def drop_history_triggers(collection_name: str, prefix: str = "t100_"):
    op.execute(
        f"DROP TRIGGER {prefix}primary_control_hx_cols "
        f"ON {pri_table_name(collection_name)}"
    )
    op.execute(
        f"DROP TRIGGER {prefix}primary_ops_to_hx "
        f"ON {pri_table_name(collection_name)}"
    )
    op.execute(
        f"DROP TRIGGER {prefix}add_foreign_hx_keys "
        f"ON {hx_table_name(collection_name)}"
    )
