"""
Plugins that add to the operations available in migrations.

This module provides a few simple additional operations, such as `set_role`,
but its major contribution is to add the operations `create_replaceable_object`,
`drop_replaceable_object`, and `replace_replaceable_object`.

For information on Alembic operation plugins, see
https://alembic.sqlalchemy.org/en/latest/api/operations.html#operation-plugins
"""

from alembic.operations import BatchOperations, Operations, MigrateOperation
from alembic.operations.ops import (
    CreateTableOp,
    AddConstraintOp,
)
from alembic import util
from alembic.util import sqla_compat


# Extended table operations

@Operations.register_operation("drop_table_if_exists")
class DropTableIfExistsOp(MigrateOperation):
    """Provide DROP TABLE IF EXISTS command."""

    def __init__(self, name, schema=None):
        self.name = name
        self.schema = schema

    @classmethod
    def drop_table_if_exists(cls, operations, name, **kw):
        """Issue a DROP TABLE IF EXISTS command."""
        op = cls(name, **kw)
        return operations.invoke(op)

    def reverse(self):
        """
        To support autogenerate.

        CAUTION: Conditional operations ("IF EXISTS") are not reliably
        reversible without memory of whether the table was actually dropped
        in the forward operation. This means a table may be incorrectly created
        in the autogenerated downgrade (I think). The user will have to add
        logic to the downgrade to solve this problem, if that is possible.
        """
        return CreateTableOp(self.name, schema=self.schema)


@Operations.implementation_for(DropTableIfExistsOp)
def drop_table_if_exists(operations, operation):
    # TODO: Refactor into a DDL extension.
    schema_prefix = (
        f"{operation.schema}." if operation.schema is not None else ""
    )
    operations.execute(f"DROP TABLE IF EXISTS {schema_prefix}{operation.name}")


@Operations.register_operation("drop_constraint_if_exists")
@BatchOperations.register_operation(
    "drop_constraint_if_exists", "batch_drop_constraint_if_exists"
)
class DropConstraintIfExistsOp(MigrateOperation):
    """
    Represent a drop constraint if exists operation.

    This code is a slightly modified version of the Alembic builtin operation
    for drop constraint (no if exists).

    TODO: DRY up by inheriting from DropConstraintOp
    """

    def __init__(
        self,
        constraint_name,
        table_name,
        type_=None,
        schema=None,
        _orig_constraint=None,
    ):
        self.constraint_name = constraint_name
        self.table_name = table_name
        self.constraint_type = type_
        self.schema = schema
        self._orig_constraint = _orig_constraint

    def reverse(self):
        if self._orig_constraint is None:
            raise ValueError(
                "operation is not reversible; "
                "original constraint is not present"
            )
        return AddConstraintOp.from_constraint(self._orig_constraint)

    def to_diff_tuple(self):
        if self.constraint_type == "foreignkey":
            return ("remove_fk", self.to_constraint())
        else:
            return ("remove_constraint", self.to_constraint())

    @classmethod
    def from_constraint(cls, constraint):
        types = {
            "unique_constraint": "unique",
            "foreign_key_constraint": "foreignkey",
            "primary_key_constraint": "primary",
            "check_constraint": "check",
            "column_check_constraint": "check",
        }

        constraint_table = sqla_compat._table_for_constraint(constraint)
        return cls(
            constraint.name,
            constraint_table.name,
            schema=constraint_table.schema,
            type_=types[constraint.__visit_name__],
            _orig_constraint=constraint,
        )

    def to_constraint(self):
        if self._orig_constraint is not None:
            return self._orig_constraint
        else:
            raise ValueError(
                "constraint cannot be produced; "
                "original constraint is not present"
            )

    @classmethod
    @util._with_legacy_names([("type", "type_"), ("name", "constraint_name")])
    def drop_constraint_if_exists(
        cls, operations, constraint_name, table_name, type_=None, schema=None
    ):
        r"""Drop a constraint of the given name, typically via DROP CONSTRAINT.

        :param constraint_name: name of the constraint.
        :param table_name: table name.
        :param type\_: optional, required on MySQL.  can be
         'foreignkey', 'primary', 'unique', or 'check'.
        :param schema: Optional schema name to operate within.  To control
         quoting of the schema outside of the default behavior, use
         the SQLAlchemy construct
         :class:`~sqlalchemy.sql.elements.quoted_name`.

         .. versionadded:: 0.7.0 'schema' can now accept a
            :class:`~sqlalchemy.sql.elements.quoted_name` construct.

        .. versionchanged:: 0.8.0 The following positional argument names
           have been changed:

           * name -> constraint_name

        """

        op = cls(constraint_name, table_name, type_=type_, schema=schema)
        return operations.invoke(op)

    @classmethod
    def batch_drop_constraint_if_exists(cls, operations, constraint_name, type_=None):
        """Issue a "drop constraint" instruction using the
        current batch migration context.

        The batch form of this call omits the ``table_name`` and ``schema``
        arguments from the call.

        .. seealso::

            :meth:`.Operations.drop_constraint`

        .. versionchanged:: 0.8.0 The following positional argument names
           have been changed:

           * name -> constraint_name

        """
        op = cls(
            constraint_name,
            operations.impl.table_name,
            type_=type_,
            schema=operations.impl.schema,
        )
        return operations.invoke(op)


@Operations.implementation_for(DropConstraintIfExistsOp)
def drop_table_if_exists(operations, operation):
    # TODO: Refactor into a DDL extension. Maybe
    schema_prefix = (
        f"{operation.schema}." if operation.schema is not None else ""
    )
    operations.execute(
        f"ALTER TABLE {schema_prefix}{operation.table_name} "
        f"DROP CONSTRAINT IF EXISTS {operation.constraint_name}"
    )


# Reversible operations

class ReversibleOperation(MigrateOperation):
    """
    Base class for reversible Alembic migration operations.

    A reversible operation is one capable of emitting create and drop
    instructions for an object, and of "reversing" the creation (or dropping)
    of such an object. It does this by accessing other migration scripts in
    order to use different (previous or later) versions, enabling an object
    from one revision to be replaced by its version from another revision.
    It does this so it can invoke the appropriate drop/create operation on
    the old object before invoking the create/drop operation on the new object
    in order to replace one with the other. Access to different versions of
    an object is provided by method `_get_object_from_version`.
    """
    def __init__(self, target, schema=None):
        self.target = target
        self.schema = schema

    @classmethod
    def invoke_for_target(cls, operations, target, **kw):
        op = cls(target, **kw)
        return operations.invoke(op)

    def reverse(self):
        raise NotImplementedError()

    @classmethod
    def _get_object_from_version(cls, operations, ident):
        version, objname = ident.split(".")

        module = operations.get_context().script.get_revision(version).module
        obj = getattr(module, objname)
        return obj

    @classmethod
    def replace(cls, operations, target, replaces=None, replace_with=None, **kw):
        """
        Migration upgrade uses `replaces`.
        Migration downgrade uses `replace_with`.
        """

        if replaces:
            old_obj = cls._get_object_from_version(operations, replaces)
            drop_old = cls(old_obj, **kw).reverse()
            create_new = cls(target, **kw)
        elif replace_with:
            old_obj = cls._get_object_from_version(operations, replace_with)
            drop_old = cls(target, **kw).reverse()
            create_new = cls(old_obj, **kw)
        else:
            raise TypeError("replaces or replace_with is required")

        operations.invoke(drop_old)
        operations.invoke(create_new)


# Replaceable object reversible operations
# 
#  The reversible operations must know how to produce create and drop
#  commands for the target objects. This is done here by requiring that any 
#  target object (a replaceable object) to provide methods `create`  and
#  `drop` that return the requisite commands. These are invoked in the
# `implementation_for` of the classes that represent the operations.
#
# Since all replaceable objects conform to the same API, we do not need
# to specialize the operations for each different kind of replaceable object
# (view, matview, stored procedure). We can have just 3 generic operations
# (`create_replaceable_object`, `drop_replaceable_object`, and
# `replace_replaceable_object`) for all the different types of replaceable
# object.

@Operations.register_operation("create_replaceable_object", "invoke_for_target")
@Operations.register_operation("replace_replaceable_object", "replace")
class CreateReplaceableObjectOp(ReversibleOperation):
    """
    Class representing a reversible create operation for a replaceable object.
    This class also requires an implementation to make it executable.
    """
    def reverse(self):
        return DropReplaceableObjectOp(self.target)


@Operations.implementation_for(CreateReplaceableObjectOp)
def create_replaceable_object(operations, operation):
    operations.execute(operation.target.create())


@Operations.register_operation("drop_replaceable_object", "invoke_for_target")
class DropReplaceableObjectOp(ReversibleOperation):
    """
    Class representing a reversible drop operation for a replaceable object.
    This class also requires an implementation to make it executable.
    """
    def reverse(self):
        return CreateReplaceableObjectOp(self.target)


@Operations.implementation_for(DropReplaceableObjectOp)
def drop_replaceable_object(operations, operation):
    operations.execute(operation.target.drop())


# Miscellaneous operations

@Operations.register_operation("set_role")
class SetRoleOp(MigrateOperation):
    """Provide SET ROLE command"""

    def __init__(self, role_name):
        self.role_name = role_name

    @classmethod
    def set_role(cls, operations, name, **kw):
        """Issue a SET ROLE command."""
        return operations.invoke(cls(name))


@Operations.implementation_for(SetRoleOp)
def set_role(operations, operation):
    # TODO: Refactor into a DDL extension.
    operations.execute(f"SET ROLE '{operation.role_name}'")


@Operations.register_operation("reset_role")
class ResetRoleOp(MigrateOperation):
    """Provide RESET ROLE command"""

    @classmethod
    def reset_role(cls, operations, **kw):
        """Issue a RESET ROLE command."""
        return operations.invoke(cls())


@Operations.implementation_for(ResetRoleOp)
def reset_role(operations, operation):
    # TODO: Refactor into a DDL extension.
    operations.execute(f"RESET ROLE")
