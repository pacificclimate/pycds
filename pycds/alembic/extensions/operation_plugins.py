"""
Plugins to extend Alembic operations.

For information on the Alembic operation plugins, see
https://alembic.sqlalchemy.org/en/latest/api/operations.html#operation-plugins

TODO: Move contents of `pycds/replaceable_objects/materialized_views.py` here.
TODO: Move contents of `pycds/replaceable_objects/views.py` here.
TODO: Move contents of `pycds/replaceable_objects/stored_procedures.py` here.
"""

from alembic.operations import Operations, MigrateOperation
from alembic.operations.ops import CreateTableOp


# Extended table operations

@Operations.register_operation("drop_table_if_exists")
class DropTableIfExistsOp(MigrateOperation):
    """
    Provide DROP TABLE IF EXISTS command.

    TODO: Look into whether it is possible to override builtin Alembic
        operations. If so, replace this with an override for the existing
        `drop_table` op that adds an `if_exists` kw arg.
    """

    def __init__(self, name, schema=None):
        self.name = name
        self.schema = schema

    @classmethod
    def drop_table_if_exists(cls, operations, name, **kw):
        """Issue a DROP TABLE IF EXISTS command."""
        op = DropTableIfExistsOp(name, **kw)
        return operations.invoke(op)

    def reverse(self):
        """
        To support autogenerate.

        CAUTION: Conditional operations ("IF EXISTS") are not reliably
        reversible without memory of whether the table was actually dropped
        in the forward operation. This means a table may be incorrectly created
        in the autogenerated downgrade (I think). The user will have to add
        logic to the downgrade to solve this problem, if that is possible.
        """
        return CreateTableOp(self.name, schema=self.schema)


@Operations.implementation_for(DropTableIfExistsOp)
def drop_table_if_exists(operations, operation):
    schema_prefix = (
        f"{operation.schema}." if operation.schema is not None else ""
    )
    operations.execute(f"DROP TABLE IF EXISTS {schema_prefix}{operation.name}")


# Reversible operations

class ReversibleOperation(MigrateOperation):
    """
    Base class for reversible Alembic migration operations.

    A reversible operation is one capable of emitting create and drop
    instructions for an object, and of "reversing" the creation (or dropping)
    of such an object. It does this by accessing other migration scripts in
    order to use different (previous or later) versions, enabling an object
    from one revision to be replaced by its version from another revision.
    It does this so it can invoke the appropriate drop/create operation on
    the old object before invoking the create/drop operation on the new object
    in order to replace one with the other. Access to different versions of
    an object is mediated by method `_get_object_from_version`.

    TODO: This isn't really right. It's what we do, but it's not necessary.
    The "target" of a reversible operation is nominally a replaceable object.
    The reversible operation has to know how to invoke the compilation of the
    create and drop operations for the target objects.
    """
    def __init__(self, target, schema=None):
        self.target = target
        self.schema = schema

    @classmethod
    def invoke_for_target(cls, operations, target, **kw):
        op = cls(target, **kw)
        return operations.invoke(op)

    def reverse(self):
        raise NotImplementedError()

    @classmethod
    def _get_object_from_version(cls, operations, ident):
        version, objname = ident.split(".")

        module = operations.get_context().script.get_revision(version).module
        obj = getattr(module, objname)
        return obj

    @classmethod
    def replace(cls, operations, target, replaces=None, replace_with=None, **kw):
        """
        Migration upgrade uses `replaces`.
        Migration downgrade uses `replace_with`.
        """

        if replaces:
            old_obj = cls._get_object_from_version(operations, replaces)
            drop_old = cls(old_obj, **kw).reverse()
            create_new = cls(target, **kw)
        elif replace_with:
            old_obj = cls._get_object_from_version(operations, replace_with)
            drop_old = cls(target, **kw).reverse()
            create_new = cls(old_obj, **kw)
        else:
            raise TypeError("replaces or replace_with is required")

        operations.invoke(drop_old)
        operations.invoke(create_new)


# Replaceable object reversible operations
#
# A replaceable object itself supplies the SQL instructions that create or
# drop the object. The Alembic create and drop operations need only execute
# those instructions.

@Operations.register_operation("create_replaceable_object", "invoke_for_target")
@Operations.register_operation("replace_replaceable_object", "replace")
class CreateReplaceableObjectOp(ReversibleOperation):
    """
    Class representing a reversible create operation for a replaceable object.
    This class also requires an implementation to make it executable.
    """
    def reverse(self):
        return DropReplaceableObjectOp(self.target)


@Operations.implementation_for(CreateReplaceableObjectOp)
def create_replaceable_object(operations, operation):
    operations.execute(operation.target.create())


@Operations.register_operation("drop_replaceable_object", "invoke_for_target")
class DropReplaceableObjectOp(ReversibleOperation):
    """
    Class representing a reversible drop operation for a replaceable object.
    This class also requires an implementation to make it executable.
    """
    def reverse(self):
        return CreateReplaceableObjectOp(self.target)


@Operations.implementation_for(DropReplaceableObjectOp)
def drop_replaceable_object(operations, operation):
    operations.execute(operation.target.drop())


# Miscellaneous operations

@Operations.register_operation("set_role")
class SetRoleOp(MigrateOperation):
    """Provide SET ROLE command"""

    def __init__(self, role_name):
        self.role_name = role_name

    @classmethod
    def set_role(cls, operations, name, **kw):
        """Issue a SET ROLE command."""
        return operations.invoke(cls(name))


@Operations.implementation_for(SetRoleOp)
def set_role(operations, operation):
    operations.execute(f"SET ROLE '{operation.role_name}'")


@Operations.register_operation("reset_role")
class ResetRoleOp(MigrateOperation):
    """Provide RESET ROLE command"""

    @classmethod
    def reset_role(cls, operations, **kw):
        """Issue a RESET ROLE command."""
        return operations.invoke(cls())


@Operations.implementation_for(ResetRoleOp)
def reset_role(operations, operation):
    operations.execute(f"RESET ROLE")
